<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIY File Beam (Robust)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PeerJS for WebRTC connection -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        }
        body {
            background: linear-gradient(135deg, #4f46e5 0%, #312e81 100%); /* Indigo */
            min-height: 100vh;
        }
        /* Pulse animation for active transfer */
        @keyframes flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .transferring {
            background: linear-gradient(270deg, #4f46e5, #818cf8, #4f46e5);
            background-size: 200% 200%;
            animation: flow 2s ease infinite;
        }
        .gear-indicator {
            transition: all 0.3s ease;
        }
        /* Manual Mode Styles */
        .manual-step {
            border-left: 3px solid #e5e7eb;
            padding-left: 1rem;
            margin-bottom: 1.5rem;
        }
        .manual-step.active {
            border-color: #4f46e5;
        }
    </style>
</head>
<body class="flex items-center justify-center p-4">

    <div class="glass-panel w-full max-w-lg rounded-2xl p-6 transition-all duration-300">
        <!-- Header -->
        <div class="text-center mb-6">
            <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-indigo-100 text-indigo-600 mb-4">
                <i class="fas fa-network-wired text-3xl"></i>
            </div>
            <h1 class="text-2xl font-bold text-gray-800">File Beam <span class="text-indigo-600">Pro</span></h1>
            
            <!-- Mode Selector -->
            <div class="mt-4 flex justify-center">
                <div class="relative inline-flex bg-gray-50 rounded-lg p-1 border border-gray-200 shadow-inner">
                    <select id="transfer-mode" onchange="updateMode()" class="bg-transparent font-bold text-xs text-indigo-700 py-2 px-4 pr-8 rounded-md focus:outline-none cursor-pointer appearance-none uppercase tracking-wide">
                        <option value="auto">Auto (Internet Required)</option>
                        <option value="manual">Manual (Copy/Paste Code)</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-indigo-500">
                        <i class="fas fa-chevron-down text-xs"></i>
                    </div>
                </div>
            </div>
        </div>

        <!-- Network Path Monitor -->
        <div id="network-monitor" class="hidden mb-6 bg-gray-50 rounded-xl p-3 border border-gray-200 text-sm transition-all duration-300">
             <div class="flex justify-between items-center mb-1">
                 <span class="text-gray-500 font-bold text-xs uppercase">Current Path</span>
                 <span id="path-type" class="font-mono font-bold text-gray-700">Connecting...</span>
             </div>
             <div class="flex justify-between items-center">
                 <span class="text-gray-500 font-bold text-xs uppercase">Latency (Ping)</span>
                 <span id="ping-stat" class="font-mono text-gray-700">-- ms</span>
             </div>
             <div id="usb-success" class="hidden mt-3 p-3 bg-emerald-50 text-emerald-700 text-xs rounded-lg border border-emerald-100 flex items-center">
                 <i class="fas fa-bolt mr-2 text-emerald-500"></i>
                 <span><strong>High Speed Active!</strong> USB connection verified.</span>
             </div>
        </div>

        <!-- Connection Status (Auto Mode) -->
        <div id="status-panel" class="mb-6 bg-white rounded-xl p-4 border border-gray-100 shadow-sm">
            <p class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">Connection Status</p>
            <div id="auto-id-display" class="flex items-center justify-between">
                <span id="my-id" class="text-lg font-mono font-bold text-indigo-600 select-all">Generating ID...</span>
                <button onclick="copyId()" class="text-gray-400 hover:text-indigo-600 transition-colors">
                    <i class="fas fa-copy"></i>
                </button>
            </div>
            
            <div class="mt-3">
                <p id="connection-status" class="text-xs flex items-center text-amber-500 font-medium">
                    <span class="w-2 h-2 rounded-full bg-amber-500 mr-2 animate-pulse"></span>
                    Waiting for connection...
                </p>
            </div>
        </div>

        <!-- Tabs -->
        <div class="flex mb-6 bg-gray-100 p-1 rounded-lg">
            <button onclick="switchTab('send')" id="tab-send" class="flex-1 py-2 rounded-md text-sm font-medium bg-white shadow-sm text-gray-800 transition-all">Sender (Phone)</button>
            <button onclick="switchTab('receive')" id="tab-receive" class="flex-1 py-2 rounded-md text-sm font-medium text-gray-500 hover:text-gray-700 transition-all">Receiver (PC)</button>
        </div>

        <!-- MANUAL HANDSHAKE UI (Hidden by default) -->
        <div id="manual-handshake-ui" class="hidden mb-6 p-4 bg-indigo-50 rounded-xl border border-indigo-100">
            <h3 class="font-bold text-indigo-900 mb-4 text-sm uppercase"><i class="fas fa-handshake mr-2"></i> Manual Handshake</h3>
            
            <!-- Step 1: Offer -->
            <div class="manual-step active" id="step-1">
                <p class="text-xs font-bold text-indigo-600 mb-1">STEP 1: SENDER</p>
                <p class="text-xs text-gray-600 mb-2">Click below to generate connection code.</p>
                <button onclick="manualCreateOffer()" class="w-full bg-indigo-600 text-white text-xs font-bold py-2 rounded hover:bg-indigo-700">Create Offer</button>
                <textarea id="manual-offer-out" readonly class="w-full h-16 mt-2 text-[10px] font-mono p-2 border rounded bg-white" placeholder="Offer code will appear here..."></textarea>
                <button onclick="copyToClipboard('manual-offer-out')" class="text-xs text-indigo-600 font-bold mt-1">Copy Offer Code</button>
            </div>

            <!-- Step 2: Answer -->
            <div class="manual-step" id="step-2">
                <p class="text-xs font-bold text-indigo-600 mb-1">STEP 2: RECEIVER</p>
                <p class="text-xs text-gray-600 mb-2">Paste Offer Code from Sender below:</p>
                <textarea id="manual-offer-in" class="w-full h-16 text-[10px] font-mono p-2 border rounded bg-white" placeholder="Paste Offer Code here..."></textarea>
                <button onclick="manualCreateAnswer()" class="w-full bg-indigo-600 text-white text-xs font-bold py-2 rounded mt-2 hover:bg-indigo-700">Generate Answer</button>
                
                <p class="text-xs text-gray-600 mt-3 mb-1">Copy this Answer Code:</p>
                <textarea id="manual-answer-out" readonly class="w-full h-16 text-[10px] font-mono p-2 border rounded bg-white" placeholder="Answer code will appear here..."></textarea>
                <button onclick="copyToClipboard('manual-answer-out')" class="text-xs text-indigo-600 font-bold mt-1">Copy Answer Code</button>
            </div>

            <!-- Step 3: Finalize -->
            <div class="manual-step" id="step-3">
                <p class="text-xs font-bold text-indigo-600 mb-1">STEP 3: SENDER</p>
                <p class="text-xs text-gray-600 mb-2">Paste Answer Code from Receiver below:</p>
                <textarea id="manual-answer-in" class="w-full h-16 text-[10px] font-mono p-2 border rounded bg-white" placeholder="Paste Answer Code here..."></textarea>
                <button onclick="manualFinalize()" class="w-full bg-green-600 text-white text-xs font-bold py-2 rounded mt-2 hover:bg-green-700">Finalize Connection</button>
            </div>
        </div>

        <!-- Auto Connect UI -->
        <div id="auto-connect-ui" class="block">
            <!-- Sender View -->
            <div id="view-send" class="block">
                <div class="space-y-4">
                    <div id="peer-connect-input">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Connect to Receiver</label>
                        <div class="flex gap-2">
                            <input type="text" id="dest-id" placeholder="Enter PC's ID here" class="flex-1 rounded-lg border-gray-300 border p-2 text-sm focus:ring-2 focus:ring-indigo-500 focus:outline-none uppercase">
                            <button onclick="connectToPeer()" id="connect-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors">
                                <i class="fas fa-link"></i>
                            </button>
                        </div>
                    </div>

                    <div class="border-2 border-dashed border-gray-300 rounded-xl p-6 text-center hover:border-indigo-500 transition-colors cursor-pointer relative">
                        <input type="file" id="file-input" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" onchange="handleFileSelect(this)">
                        <div id="drop-zone-text">
                            <i class="fas fa-cloud-upload-alt text-3xl text-gray-400 mb-2"></i>
                            <p class="text-sm text-gray-500">Tap to select file</p>
                        </div>
                    </div>
                    
                    <div id="action-area">
                        <button onclick="startTransfer()" id="send-btn" class="w-full bg-gray-300 text-gray-500 font-bold py-3 rounded-xl cursor-not-allowed transition-all" disabled>
                            Start Transfer
                        </button>
                    </div>
                </div>
            </div>

            <!-- Receiver View -->
            <div id="view-receive" class="hidden">
                <div id="default-recv-ui" class="text-center p-8 bg-gray-50 rounded-xl border border-gray-100">
                    <div class="mb-4">
                        <i class="fas fa-satellite-dish text-4xl text-indigo-300"></i>
                    </div>
                    <h3 class="font-bold text-gray-800 mb-2">Ready to Receive</h3>
                    <p class="text-sm text-gray-500 mb-4" id="recv-instruction">Share your ID above with the sender.</p>
                    <div id="fs-warning" class="hidden text-xs text-green-600 bg-green-50 p-2 rounded border border-green-100">
                        <i class="fas fa-check-circle mr-1"></i> Fast Disk Write Active
                    </div>
                </div>

                <!-- NEW: Incoming Request UI -->
                <div id="incoming-req-ui" class="hidden text-center p-6 bg-indigo-50 rounded-xl border border-indigo-200">
                    <div class="mb-4 animate-bounce">
                        <i class="fas fa-file-import text-4xl text-indigo-600"></i>
                    </div>
                    <h3 class="font-bold text-indigo-900 mb-1">Incoming File Request</h3>
                    <p class="text-sm text-indigo-600 mb-4" id="incoming-filename">filename.mp4</p>
                    <p class="text-xs text-gray-500 mb-6" id="incoming-filesize">0 GB</p>
                    <button onclick="acceptTransfer()" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-xl hover:bg-indigo-700 transition-all shadow-md">
                        <i class="fas fa-download mr-2"></i> Accept & Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Progress Overlay -->
        <div id="progress-panel" class="hidden mt-6">
            <div class="flex justify-between text-sm mb-1">
                <span class="font-medium text-gray-700" id="progress-text">Transferring...</span>
                <span class="font-bold text-indigo-600" id="progress-percent">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 overflow-hidden">
                <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div class="flex justify-between items-center mt-2">
                <div class="flex items-center space-x-2 text-xs text-gray-500">
                    <i class="fas fa-tachometer-alt"></i>
                    <span id="gear-text" class="gear-indicator font-mono">Gear 1 (64KB)</span>
                </div>
                <p id="speed-text" class="text-xs text-gray-500 font-mono text-right">0.0 MB/s</p>
            </div>
        </div>

    </div>

    <script>
        // --- Global State ---
        let peer = null; // Auto mode
        let conn = null; // Can be Auto or Manual wrapper
        let myId = '';
        let selectedFile = null;
        let fileHandle = null;
        let writableStream = null;
        let transferActive = false;
        let manualPC = null; // RTCPeerConnection for Manual Mode
        let manualDC = null; // DataChannel for Manual Mode
        let incomingMetadata = null; // Store metadata while waiting for accept
        
        // Stats
        let statsInterval = null;
        let lastTime = Date.now();
        let lastOffset = 0;
        
        // --- Initialization ---
        function init() {
            // Check for File System Access API
            if ('showSaveFilePicker' in window) {
                document.getElementById('fs-warning').classList.remove('hidden');
            }
            // Start in Auto Mode by default
            startAutoMode();
        }

        function updateMode() {
            const mode = document.getElementById('transfer-mode').value;
            if (mode === 'manual') {
                document.getElementById('manual-handshake-ui').classList.remove('hidden');
                document.getElementById('peer-connect-input').classList.add('hidden'); // Hide ID input in manual
                document.getElementById('status-panel').classList.add('hidden'); // Hide PeerID display
                document.getElementById('recv-instruction').innerText = "Follow Manual Steps above.";
                
                // Reset PeerJS to avoid conflicts
                if(peer) peer.destroy();
                peer = null;
            } else {
                document.getElementById('manual-handshake-ui').classList.add('hidden');
                document.getElementById('peer-connect-input').classList.remove('hidden');
                document.getElementById('status-panel').classList.remove('hidden');
                document.getElementById('recv-instruction').innerText = "Share your ID above with the sender.";
                startAutoMode();
            }
        }

        // --- AUTO MODE (PeerJS) ---
        function startAutoMode() {
            const peerConfig = { 
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            };
            const shortId = Math.random().toString(36).substring(2, 6).toUpperCase();
            
            try {
                peer = new Peer(shortId, peerConfig);

                peer.on('open', (id) => {
                    myId = id;
                    document.getElementById('my-id').innerText = id;
                });

                peer.on('connection', (connection) => {
                    handleConnection(connection);
                });

                peer.on('error', (err) => {
                    console.error("PeerJS Error:", err);
                    setConnStatus("Error: " + err.type, "red");
                });
            } catch(e) {
                console.error("PeerJS Init Failed", e);
            }
        }

        function connectToPeer() {
            const destId = document.getElementById('dest-id').value.toUpperCase();
            if (!destId) return alert("Please enter the ID");
            setConnStatus("Initializing handshake...", "amber");
            conn = peer.connect(destId, { reliable: true, serialization: 'binary' });
            handleConnection(conn);
        }

        // --- MANUAL MODE (Native WebRTC) ---
        // Mimics the 'conn' interface of PeerJS so existing logic works
        
        async function createManualPC() {
            const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            manualPC = new RTCPeerConnection(config);
            
            manualPC.onicecandidate = e => {
                // Wait for all candidates (null) or just show current
                if (e.candidate === null) {
                    const offerJSON = JSON.stringify(manualPC.localDescription);
                    // Update the text areas based on signaling state
                    if (manualPC.localDescription.type === 'offer') {
                        document.getElementById('manual-offer-out').value = offerJSON;
                    } else {
                        document.getElementById('manual-answer-out').value = offerJSON;
                    }
                }
            };

            manualPC.ondatachannel = e => {
                setupManualDataChannel(e.channel);
            };
        }

        function setupManualDataChannel(dc) {
            manualDC = dc;
            manualDC.binaryType = 'arraybuffer';
            
            // Create a wrapper that looks like PeerJS 'conn'
            conn = {
                open: true,
                send: (data) => manualDC.send(data),
                peerConnection: manualPC, // For stats
                dataChannel: manualDC, // For buffer check
                on: (event, cb) => {
                    if (event === 'data') manualDC.onmessage = (e) => cb(e.data);
                    if (event === 'close') manualDC.onclose = cb;
                    if (event === 'open') {
                        if(manualDC.readyState === 'open') cb();
                        else manualDC.onopen = cb;
                    }
                }
            };

            manualDC.onopen = () => {
                setConnStatus("Manual Connection Open!", "green");
                document.getElementById('manual-handshake-ui').classList.add('hidden'); // Hide manual UI on success
                document.getElementById('status-panel').classList.remove('hidden'); // Show status
                startNetworkStats();
            };
            
            manualDC.onclose = () => {
                setConnStatus("Disconnected", "red");
                stopNetworkStats();
            };
        }

        // Step 1: Sender creates Offer
        async function manualCreateOffer() {
            await createManualPC();
            const dc = manualPC.createDataChannel("file-beam");
            setupManualDataChannel(dc);
            
            const offer = await manualPC.createOffer();
            await manualPC.setLocalDescription(offer);
            document.getElementById('manual-offer-out').value = "Generating candidates... please wait...";
        }

        // Step 2: Receiver takes Offer, creates Answer
        async function manualCreateAnswer() {
            const offerStr = document.getElementById('manual-offer-in').value;
            if(!offerStr) return alert("Paste the Offer first!");
            
            await createManualPC();
            await manualPC.setRemoteDescription(JSON.parse(offerStr));
            const answer = await manualPC.createAnswer();
            await manualPC.setLocalDescription(answer);
            document.getElementById('manual-answer-out').value = "Generating candidates... please wait...";
        }

        // Step 3: Sender takes Answer
        async function manualFinalize() {
            const answerStr = document.getElementById('manual-answer-in').value;
            if(!answerStr) return alert("Paste the Answer first!");
            
            await manualPC.setRemoteDescription(JSON.parse(answerStr));
        }


        // --- COMMON LOGIC (Handlers) ---

        function handleConnection(connection) {
            conn = connection;
            
            // Auto Mode handlers
            conn.on('open', () => {
                setConnStatus("Connected securely!", "green");
                startNetworkStats();
            });

            conn.on('data', async (data) => {
                handleIncomingData(data);
            });

            conn.on('close', () => {
                setConnStatus("Disconnected", "red");
                stopNetworkStats();
                if(transferActive) cancelTransfer();
            });
            
            // PeerJS ICE monitoring
            if(conn.peerConnection) {
                 conn.peerConnection.oniceconnectionstatechange = () => {
                    const state = conn.peerConnection.iceConnectionState;
                    if(state === 'failed' || state === 'disconnected') setConnStatus("Connection Failed", "red");
                };
            }
        }

        function setConnStatus(text, colorClass) {
            const el = document.getElementById('connection-status');
            let color = "text-gray-500";
            if(colorClass === 'amber') color = "text-amber-500";
            if(colorClass === 'red') color = "text-red-500";
            if(colorClass === 'green') color = "text-green-600";
            
            el.className = `text-xs flex items-center font-medium ${color}`;
            el.innerHTML = `<span class="w-2 h-2 rounded-full bg-${colorClass}-500 mr-2 ${colorClass === 'amber' ? 'animate-pulse' : ''}"></span> ${text}`;
        }

        // --- Stats & Diagnostics ---
        function startNetworkStats() {
            document.getElementById('network-monitor').classList.remove('hidden');
            document.getElementById('path-type').innerText = "Analyzing Path...";
            
            if(statsInterval) clearInterval(statsInterval);
            
            statsInterval = setInterval(async () => {
                // Compatible with both PeerJS and Manual (both have .peerConnection)
                if(!conn || !conn.peerConnection) return;
                
                try {
                    const stats = await conn.peerConnection.getStats();
                    let rtt = null;
                    stats.forEach(report => {
                        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                            rtt = report.currentRoundTripTime * 1000;
                        }
                    });

                    if(rtt !== null) {
                         document.getElementById('ping-stat').innerText = rtt.toFixed(1) + " ms";
                         const pathEl = document.getElementById('path-type');
                         
                         if (rtt < 8) {
                             pathEl.innerHTML = `<span class="text-emerald-600 font-bold">USB / LAN</span>`;
                             document.getElementById('usb-success').classList.remove('hidden');
                         } else {
                             pathEl.innerHTML = `<span class="text-amber-600">Wi-Fi / Slow</span>`;
                         }
                    }
                } catch(e) { console.log("Stats error", e); }
            }, 1000);
        }
        
        function stopNetworkStats() {
            if(statsInterval) clearInterval(statsInterval);
            document.getElementById('network-monitor').classList.add('hidden');
        }

        // --- File Handling (Chunk Reader) ---
        function readChunk(file, offset, length) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => resolve(null); 
                reader.readAsArrayBuffer(file.slice(offset, offset + length));
            });
        }

        function handleFileSelect(input) {
            if (input.files.length > 0) {
                selectedFile = input.files[0];
                document.getElementById('drop-zone-text').innerHTML = 
                    `<i class="fas fa-file-video text-3xl text-indigo-500 mb-2"></i>
                     <p class="text-sm font-bold text-gray-700">${selectedFile.name}</p>
                     <p class="text-xs text-gray-500">${(selectedFile.size / (1024*1024*1024)).toFixed(2)} GB</p>`;
                
                const btn = document.getElementById('send-btn');
                btn.disabled = false;
                btn.classList.remove('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
                btn.classList.add('bg-indigo-600', 'text-white', 'hover:bg-indigo-700');
            }
        }

        function cancelTransfer() {
            transferActive = false;
            if (conn && conn.open) conn.send({ type: 'cancel' });
            resetTransferUI();
            alert("Transfer Cancelled");
        }

        // --- SENDER LOGIC ---
        async function startTransfer() {
            if (!conn || !conn.open) return alert("Not connected to Receiver!");
            if (!selectedFile) return;

            const actionArea = document.getElementById('action-area');
            actionArea.innerHTML = `
                <button class="w-full bg-gray-400 text-white font-bold py-3 rounded-xl cursor-wait shadow-md">
                    <i class="fas fa-spinner fa-spin mr-2"></i> Waiting for Accept...
                </button>
            `;

            // Step 1: Send Metadata and wait for 'ack'
            conn.send({
                type: 'metadata',
                name: selectedFile.name,
                size: selectedFile.size,
                mime: selectedFile.type
            });
        }
        
        // Step 2: Received ACK, start actual data loop
        async function startSendingData() {
            const actionArea = document.getElementById('action-area');
            actionArea.innerHTML = `
                <button onclick="cancelTransfer()" class="w-full bg-red-500 text-white font-bold py-3 rounded-xl hover:bg-red-600 transition-all shadow-md">
                    <i class="fas fa-stop-circle mr-2"></i> Stop Transfer
                </button>
            `;

            document.getElementById('progress-panel').classList.remove('hidden');
            document.getElementById('progress-bar').classList.add('transferring');
            
            transferActive = true;

            // ADAPTIVE GEAR SYSTEM
            const GEARS = [32*1024, 64*1024, 128*1024, 256*1024, 512*1024];
            let currentGearIndex = 1; 
            let chunkSize = GEARS[currentGearIndex]; 
            const MAX_BUFFER = 16 * 1024 * 1024; 

            let offset = 0;
            lastTime = Date.now();
            lastOffset = 0;
            let chunksSentSinceCheck = 0;

            while (offset < selectedFile.size && transferActive) {
                // Flow control
                if (conn.dataChannel.bufferedAmount > MAX_BUFFER) {
                    await new Promise(r => setTimeout(r, 0));
                    if (currentGearIndex > 0 && Math.random() > 0.9) { 
                        currentGearIndex--;
                        chunkSize = GEARS[currentGearIndex];
                        updateGearUI(currentGearIndex, chunkSize);
                    }
                    continue; 
                }

                if (conn.dataChannel.bufferedAmount === 0 && currentGearIndex < GEARS.length - 1) {
                     if (chunksSentSinceCheck > 50) {
                        currentGearIndex++;
                        chunkSize = GEARS[currentGearIndex];
                        updateGearUI(currentGearIndex, chunkSize);
                        chunksSentSinceCheck = 0;
                     }
                }

                const chunk = await readChunk(selectedFile, offset, chunkSize);
                if (!chunk) break; 

                conn.send({ type: 'chunk', data: chunk });
                offset += chunk.byteLength;
                chunksSentSinceCheck++;
                
                if (chunksSentSinceCheck % 5 === 0) updateProgress(offset, selectedFile.size);
            }
            
            if (transferActive) {
                updateProgress(selectedFile.size, selectedFile.size);
                conn.send({ type: 'end' });
                setConnStatus("Transfer Complete", "green");
                resetTransferUI();
            }
        }

        // --- RECEIVER LOGIC ---
        let receivedSize = 0;
        let totalSize = 0;
        let incomingFileName = "";
        let receiveBuffer = [];

        async function handleIncomingData(data) {
            // 1. Receive Metadata -> Show Accept UI
            if (data.type === 'metadata') {
                incomingMetadata = data; // Store for accept action
                
                // Show UI
                document.getElementById('default-recv-ui').classList.add('hidden');
                document.getElementById('incoming-req-ui').classList.remove('hidden');
                document.getElementById('incoming-filename').innerText = data.name;
                document.getElementById('incoming-filesize').innerText = (data.size / (1024*1024*1024)).toFixed(2) + " GB";
            
            // 2. Sender received ACK -> Start sending
            } else if (data.type === 'ack') {
                startSendingData();

            // 3. Receive Chunks
            } else if (data.type === 'chunk' && transferActive) {
                receivedSize += data.data.byteLength;
                if (receivedSize % (512*1024) < 64*1024) updateProgress(receivedSize, totalSize);

                if (writableStream) {
                    await writableStream.write(data.data);
                } else {
                    receiveBuffer.push(data.data);
                }

            } else if (data.type === 'end') {
                updateProgress(totalSize, totalSize);
                finishReceive();
            } else if (data.type === 'cancel') {
                alert("The other party cancelled the transfer.");
                if (writableStream) await writableStream.abort();
                resetTransferUI();
            }
        }
        
        // Receiver clicks "Accept"
        async function acceptTransfer() {
            if(!incomingMetadata) return;
            
            totalSize = incomingMetadata.size;
            incomingFileName = incomingMetadata.name;
            receivedSize = 0;
            receiveBuffer = [];
            lastTime = Date.now();
            lastOffset = 0;
            transferActive = true;
            
            // Hide Request UI
            document.getElementById('incoming-req-ui').classList.add('hidden');
            document.getElementById('default-recv-ui').classList.remove('hidden');
            
            // Show Progress UI
            document.getElementById('progress-panel').classList.remove('hidden');
            document.getElementById('progress-bar').classList.add('transferring');
            document.getElementById('progress-text').innerText = `Receiving: ${incomingFileName}`;

            // Try File Handle (MUST be triggered by this user gesture)
            if ('showSaveFilePicker' in window) {
                try {
                    fileHandle = await window.showSaveFilePicker({ suggestedName: incomingFileName });
                    writableStream = await fileHandle.createWritable();
                    // SUCCESS! Tell Sender to go.
                    conn.send({type: 'ack'});
                } catch (err) {
                    console.log("Save cancelled or failed", err);
                    conn.send({type: 'cancel'});
                    resetTransferUI();
                }
            } else {
                // Fallback for no File System API
                conn.send({type: 'ack'});
            }
        }

        async function finishReceive() {
            document.getElementById('progress-bar').classList.remove('transferring');
            if (writableStream) {
                await writableStream.close();
                alert("File Saved Successfully!");
            } else {
                const blob = new Blob(receiveBuffer);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = incomingFileName;
                a.click();
            }
            resetTransferUI();
        }

        // --- Utilities ---
        function resetTransferUI() {
            transferActive = false;
            incomingMetadata = null;
            document.getElementById('action-area').innerHTML = `
                <button onclick="startTransfer()" id="send-btn" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-xl hover:bg-indigo-700 transition-all">
                    Start Transfer
                </button>
            `;
            setTimeout(() => {
                document.getElementById('progress-panel').classList.add('hidden');
                document.getElementById('progress-bar').style.width = "0%";
                // Reset receiver UI
                document.getElementById('incoming-req-ui').classList.add('hidden');
                document.getElementById('default-recv-ui').classList.remove('hidden');
            }, 2000);
            writableStream = null;
            receiveBuffer = [];
        }

        function updateGearUI(index, size) {
            const kb = Math.round(size/1024);
            const el = document.getElementById('gear-text');
            el.innerText = `Gear ${index+1} (${kb}KB)`;
        }

        function switchTab(tab) {
            document.getElementById('tab-send').className = tab === 'send' 
                ? "flex-1 py-2 rounded-md text-sm font-medium bg-white shadow-sm text-gray-800 transition-all"
                : "flex-1 py-2 rounded-md text-sm font-medium text-gray-500 hover:text-gray-700 transition-all";
            
            document.getElementById('tab-receive').className = tab === 'receive' 
                ? "flex-1 py-2 rounded-md text-sm font-medium bg-white shadow-sm text-gray-800 transition-all"
                : "flex-1 py-2 rounded-md text-sm font-medium text-gray-500 hover:text-gray-700 transition-all";

            document.getElementById('view-send').className = tab === 'send' ? "block" : "hidden";
            document.getElementById('view-receive').className = tab === 'receive' ? "block" : "hidden";
        }

        function updateProgress(current, total) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progress-bar').style.width = percent + "%";
            document.getElementById('progress-percent').innerText = percent + "%";
            
            const now = Date.now();
            const timeDiff = now - lastTime;
            
            if (timeDiff > 1000) {
                const bytesDiff = current - lastOffset;
                const speedBps = (bytesDiff / timeDiff) * 1000;
                const speedMBps = (speedBps / (1024 * 1024)).toFixed(1);
                
                document.getElementById('speed-text').innerText = `${speedMBps} MB/s`;
                lastTime = now;
                lastOffset = current;
            }
        }

        function copyId() {
            navigator.clipboard.writeText(myId);
            alert("ID Copied!");
        }

        function copyToClipboard(id) {
            const el = document.getElementById(id);
            el.select();
            navigator.clipboard.writeText(el.value);
            alert("Copied to clipboard!");
        }

        // Start App
        init();
    </script>
</body>
</html>
